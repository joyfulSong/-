// 투포인트 알고리즘 응용 (포인트는 배열을 가리키는 인덱스로서 쓰인다.)
// 해외 회사에서도 자주 나온다. 
// for문으로 각 숫자마다 소인수가 2,3,5인지 확인하면 입력값까지 도는 for문 + 그 숫자에 대한 소인수확인 다중 for문으로 타임리밋난다. 

// 시작수를 1로 하고, 2, 3, 5만을 곱해서 1이후의 숫자들을 써나간다. 
// 그 수들 만을 곱했기 때문에 다른 소인수로 이루어진 수는 나타나지 않는다. 

// p2, p3, p5 각각은 포인트로 각 포인트가 가리키는 숫자에 2, 3, 5를 곱한 수 중 최솟값을 현재의 배열에 넣는다.
// 최솟값을 만든 포인트는 증가시키며, 만약 최솟값을 두개의 포인트가 만들면 둘다 증가시킨다.
// 포인트의 역할은 2,3,5가 영향을 미치는 수, 즉 배수의 진행단계를 기억하기 위함이다. 
// 4를 만들때 2자리에 있던 p2가 3으로 이동했고, 6을 만들 때 p2위치의 3에 2를 곱한값이 6을 만들게 된다. 

#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main()
{
	int	n, p2, p3, p5, min = -2147000000; //셋 중에 최솟값 알아야해서.
	int a[1501];

	cin >> n;

	a[1] = 1;
	a[p2] = a[p3] = a[p5]= 1;
	for (int i = 2; i < n + 1; i++) {
		if (a[p2] * 2 > a[p3] * 3) min = a[p2] * 2;
		else min = a[p3] * 3; // p3*3이 더 크면.
		if (a[p5] * 5 < min) min = a[p5] * 5; // p2, p3통해 구한 min 값보다도 작으면 갱신
		// 위 내용으로 세 포인트를 통한 min값을 찾는다.

		if (min == a[p2] * 2) p2++;
		if (min == a[p3] * 3) p3++;
		if (min =- a[p5] * 5) p5++;
		a[i] = min;
	}

	cout << min;

	return 0;
}
