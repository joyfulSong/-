//맨 위노드가 루트 노드. 여기서부터 바로 연결된, 갈 수 있는 노드들을 방문한다.
// 넓이 우선 탐색은 레벨 탐색으로 큐 자료구조를 사용한다. 먼저 들어간 것이 제일 먼저 나온다.
// 반면 깊이 우선 탐색은 스택을 사용해 먼저 들어간 것이 가장 바닥에 쌓여 제일 나중에 나온다.
// 레벨 탐색은 어떤 레벨까지 가기 위해 필요한 최소횟수를 구할 수 있게 한다.
#include <iostream>
#include <vector> 
#include <algorithm>

using namespace std;

int Q[100], front = -1, back = -1, ch[100];
// 큐자료구조의 원리를 배열에 적용해 구현해보자. front는 꺼내는 용도의 포인터로 큐에서 어디까지 꺼냈는지를 기억하고, back은 넣는 용도의 포인트롤 어디까지 넣었는지 기억한다.
// 무방향 그래프(리스트)를 사용할 것이므로 어떤 노드를 방문했는지 알기 위해 체크배열을 사용해준다.
vector<int> map[100]; // 인접리스트를 사용해 그래프를 입력받자.

int main()
{
	int a, b;
	//간선정보 6개에 대해 인접리스트를 만든다. 무방향그래프.
	for (int i = 1; i < 7; i++) {
		cin >> a >> b;
		map[a].push_back(b);
		map[b].push_back(a); 
	}

	//1 넣기부터 시작
	Q[++back] = 1;
	ch[1] = 1;

	//큐에서 나온노드와 연결된 가장 가까운 노드들을 넣어준다. x에 저장해두고 사용
	//먼저 넣고(back 증가) 그다음에 빼므로(front) front가 back보다 더 작다. 하지만 front == back이 되면 넣은것을 모두 뺐다는 것으로 큐가 비어있게 되어 while문이 종료된다.
	while (front < back) {
		// 하나 빼고 연결된 노드들을 뒤에 넣어주는것을 반복.
		int x = Q[++front]; //선 출 후 증가
		cout << x << " "; //뺀것 출력: 넓이 우선탐색을 한 결과

		if (int i = 0; i < map[x].size(); i++) {
			//인접리스트인 map에서 x가 방문가능한 노드들을 탐색한다. 
			if (ch[map[x][i]] == 0) {
				ch[map[x][i]] = 1;
				Q[++back] = map[x][i];
			}
		}
	}
	return 0;
	
}