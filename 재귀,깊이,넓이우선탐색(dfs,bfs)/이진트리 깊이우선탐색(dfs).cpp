//이진트리는 부모, 왼쪽 자식, 오른쪽 자식 노드로 이뤄져 있다. 
// 자식노드를 이루는 규칙을 통해 노드를 재귀함수를 호출해 만들 수 있다.

// DFS는 출발노드에서 연결된 노드 중 하나를 선택해 이동해 나가다가 더이상 갈 곳이 없으면 되돌아가서 안가본 길로 간다. 이와 같이 전체를 순회한다. 
// 부모노드가 언제 출력되느냐에 따라 전위, 중위, 후위순회로 나뉜다. 
// 전위 순회는 부모먼저 출력, 왼쪽 자식, 오른쪽 자식순으로 출력된다. 
// 중위 순회는 왼쪽자식, 부모, 오른쪽 자식 순으로 출력된다.
// 후위 순회는 왼쪽 자식, 오른쪽 자식, 부모 순으로 출력된다. 병합정렬이 후위순회를 사용한다. 
// subtree가 있다면 왼쪽 혹은 오른쪽 자식도 부모 노드가 될 수 있는 것이다.
// 예) 왼쪽 subtree가 끝나고 그의 부모노드 출력, 오른쪽 subtree를 진행하는 식으로 중위순회가 일어난다.

#include <iostream>
#include <vector>
#include <stack> 
#include <algorithm>
using namespace std;

//스택에는 매개변수 몇으로 들어가 몇번라인까지 진행됐는지 저장되어 있다. 해당 함수의 프로세스가 끝나면 그 아래 스택에서 마저 진행한다.
void D(int n) {
	if (n > 7) return;
	else {
		cout << n; //전위: 현재 노드 출력 후 왼쪽 노드, 오른쪽 노드.
		D(n * 2); //재귀함수 이므로 v>7로 false나서 끝나고나면 이 위치로 돌아와 다음 라인인 오른쪽 노드 만드는 곳으로 진행한다. 
		// cout << n; 중위
		D(n * 2 + 1);
		// cout << n; 후위
		// 트리에서 실제 하는 일이 어디에 위치하느냐에 따라 전위 중위 후위가 달렸다. 
	}
}
int main()
{
	int n = 1;
	D(n);
	return 0;
}

