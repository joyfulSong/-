// 최단거리는 bfs로 구한다. 1에서 각 노드에 도달하는데 걸리는 최소 거리를 구할 때,
// 1에서 한번 이동으로 갈 노드를 탐색하고, 체크해버리고
// 1에서 두번 이동으로 갈 노드를 탐색하고, 체크해버리면
// 1에서 세번 이동으로 갈 노드에는 앞서 체크된 노드들을 체크할 수 없다. 따라서 해당노드까지의 거리에 대해 탐색이 끝나버리므로 최소거리가 나온다.
#include <iostream>
#include <vector> 
#include <queue>
#include <algorithm>

using namespace std;

int dis[30], ch[30];
// dis에는 각 정점까지 가는데 필요한 최소거리를 저장한다. 1에서 4까지가는데 1번이동이면 dis[4] = 1이고,
// 1에서 5까지가는데 4로 한번이동, 5로 한번이동이면, dis[4] + 1인 2가 들어간다.
// 어떤 정점을 이미 방문했는지 확인하는 용도의 ch배열도 사용해준다.
int main()
{
	int n, m, a, b;
	vector<int> map[30];
	queue<int> Q[30];

	cin >> n >> m;
	for (int i = 1; i < m; i++) {
		cin >> a >> b;
		map[a].push_back(b); // 방향 그래프이다.
	}

	//큐 이용해 탐색, 1부터 저장한다. 
	Q->push(1);
	ch[1] = 1;

	while (!Q->empty()) {
		//q가 비면 empty는 1반환, 사용중이면 0이므로, 낫붙여서 큐가 진행중이면 1이되도록한다. (앞선 front < back과 동일)
		int x = Q->front(); // 큐의 맨앞 요소를 참조 복사해 x에 넣기. pop은아니다.
		Q->pop(); // 맨 앞의 것 하나 꺼내기

		for (int i = 0; i < map[x].size(); i++) {
			if (ch[map[x][i]] == 0) {
				ch[map[x][i]] = 1;
				Q->push(map[x][i]); // x에서 탐색 가능한 노드들을 넣는다.
				dis[map[x][i]] = dis[x] + 1; // x에서 한칸이동으로 간 map[x][i]는 1에서 x까지 이동하는데 든 거리인 dis[x]에 +1한 것이다.
			}
		}
	}

	for (int i = 2; i < n + 1; i++) {
		cout << i << " : " << dis[i] << "\n";
	}
}

//x가 계속 바뀌는데도 1에서의 최단거리를 알 수 있는 것은, 비록 그래프가 트리형태는 아니지만 마찬가지로,
//x에서 방문가능한 노드들을 다 탐색하고 체크하고 1기준으로 만들어진 거리에 대해 +1을 해주므로,
//dis에 저장되는 값은 1을 기준으로 한 것이고, 앞서 체크가 된 노드는 방문할 수 없기에 결국엔 다 돌 수 있게 되는 것이다. 