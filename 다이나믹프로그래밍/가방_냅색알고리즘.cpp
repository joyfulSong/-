//냅색 알고리즘
//i로는 보석의 무게와 가치를 하나씩 읽고, j포문으로는 가방에 j무게까지 담을 수 있을 때의 보석의 최대가치값을 저장한다.
//가방이 비어있을 때 dy[j==0]에 무게 5짜리를 넣고 나면 가방에 5무게까지 담았을때 d[j==5]에는 5짜리의 가치가 들어있게 된다.
//이를 수식화 하면 dy[j] = dy[j-w] + v
// d[5]에는 5까지 담을 수 있는데, 현재담아볼 보석이 3무게라면, dy[5-3]==dy[2] 앞선단계에 2까지 담았던것에 3을 넣어서 5를 만드는 것이므로, dy[2]+3의 값과 dy[5]의 값을 비교해본다. 
// 기존에 담아놨던 가치보다 3을 담았을 때의 가치가 더 작으면 3을 안담는다. (기존상태를 최상으로 둔다.)

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
	int n, m, w, v; //weight, value
	cin >> n >> m;

	vector<int> dy(m + 1, 0); //가방 무게 0일때의 가치부터 m일때의 가치까지이므로. 0으로 초기화

	for (int i = 0; i < n; i++) { //n개의 보석을 입력받는다.
		cin >> w >> v;
		for (int j = w; j < m + 1; j++) { //dy테이블의 0부터 m까지 돌면서 가치를 갱신한다.
			dy[j] = max(dy[j], dy[j - w] + v);
		}
	}
	cout << dy[m];
}