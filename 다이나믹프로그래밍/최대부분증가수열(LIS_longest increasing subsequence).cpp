//bottom up 방식: 어떤 배열값을 마지막으로 해서 만들 수 있는 부분 증가수열은, 그 배열값보다 작으면서 앞에 존재하는 수들에 저장되어있는 값(그작은 값을 마지막으로 했을 때 얻을 수 있는 부분증가수열의 길이) 들 중 가장 큰 값에 +1한것이다.
//저장된 dy값 중에 치댓값을 출력해야한다. (마지막 수를 마지막항으로 하는 최대 길이 출력이 아니다.)

// 5번
// 왼쪽이 증가수열이므로, 오른쪽도 증가수열이어야함. 오른쪽에서 감소하는 수열을 선택해 연결하려면 연결하는 선이 교차하게 됨.
// 즉, 최대 부분 증가수열을 찾는 문제이다.
// 비슷하게, 선을 서로 연결해놓고, 몇개의 선을 없애면 교차하지 않는 선만 남기냐: 전체 선의 개수 - 최대 부분 증가수열의 갯수(교차하지 않는 선의 수)를 한게 없애야할 선의 수이다.
#include <iostream>
#include <vector> 
#include <queue>
#include <algorithm>

using namespace std;

int main()
{
	int n, res = 0;
	cin >> n;
	vector<int> a(n + 1), dy(n + 1); //1부터 저장할 것임.

	for (int i = 1; i < n + 1; i++) {
		cin >> a[i];
	}

	dy[1] = 1; // 맨앞의 수를 마지막 수로 했을 때 부분증가수열은 자기자신밖에 없다.
	for (int i = 2; i < n + 1; i++) {
		int max = 0;
		for (int j = i - 1; j >= 1; j--) {
			//i하나를 잡고 i보다 앞선 위치에 있는 수들 중 작은 값, 그중 max보다 큰 값에+1 한것을 저장한다.
			if (a[i] > a[j] && dy[j] > max) {
				max = dy[j]; //max갱신, 마저 j for문 돈다.
			}
		}
		dy[i] = max + 1; // 최종적으로 얻은 max에 +1한값.
		if (dy[i] > res) res = dy[i]; // 답값 갱신
	}

	cout << res;
	return 0;
}



