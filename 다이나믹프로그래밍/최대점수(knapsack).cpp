// 앞문제와의 차이점은 한문제당 한번만 풀 수 있기 때문.
// 기존에 하던데로 1차원 배열로 j포문을 돌리면 10점짜리가 5시간에서 1번 10시간에서 2번이 되어 점수가 누적이 된다.
// 이를 방지하기 위해서 2차원배열로, dy[i-1][j-t]+s를 한다: 
// i는 행, 각 문제유형 번호이고, j는 시간이다. i-1행의 값을 참조하므로, 이전 문제를 풀 때 저장해둔 값을 가져온다는 것이므로 현재문제를 풀며 발생한 값이 아니니 중복이 발생하지 않는다.
// 또한 j-t인것은 j-t시간에서 +t시간으로서 s값을 얻었기 때문이다.
// 2차원배열을 0으로 초기화해두고, dy[i][j] = max(dy[i][j], dy[i-1][j-t]+s)로해도 되지만,

//메모리절약과 코드 간결성으로 1차원 배열로 가능하다. 
//앞에서부터 값을 저장해나가는 것이 아니라, m시간, 맨뒤에서부터 채워나가면, 앞부분에는 현재문제에 대한 적용이 안된 상태이므로 문제를 중복해서 사용하지 않게 된다. 

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
	int n, m, s, t;
	cin >> n >> m;

	vector<int> dy(m + 1, 0);

	for (int i = 0; i < n; i++) {
		cin >> s >> t;
		for (int j = m; j >= t; j--) {  //아래 점화식에서 배열 인덱스값이 음수가 되는 것을 방지하도록. t까지만 돈다.
			dy[j] = max(dy[j], dy[j - t] + s);
		}
	}
	cout << dy[m];
}
