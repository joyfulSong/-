// 다익스트라, 벨만은 한정점에서 다른 정점을의 최단거리인데, 플로이드 와샬은 냅색 알고리즘 처럼 모든 노드를 중간노드로 두었을때를 다 적용해 최솟값을 저장함으로서, 
// 모든 노드에서 모든 노드를 방문할 때 드는 최소 비용을 계산하도록 하는 알고리즘이다. 
// dis[i][j] == i에서 j로 가는데 드는 최소 비용. 

//최초 초기화는 중간 노드 없이 간선 1개로 가는 == 인접행렬에 대한 비용이다. (안되는 곳은 max 5000으로 초기화)
//i에서 j로 간다는 것은 i와 j 사이의 노드를 경유지로 사용해서 가는 것으로: 1에서 5로 가려면 2,3,4를 사용할 수 있다.(순열): dis[i][k]+dis[k][j]
//초기화한 값인 i에서 j로 바로 가는 값보다 거치는 값이 작으면 릴렉스해준다.

//냅색알고리즘과 비슷한 이유는 노드가 5개이면 k는 1,2,3,4,5로 모두 돌며 i에서 k를 지나 j로 가는값을 기존값과 비교해 적용함으로서, for문이 종료되면 모든 k를 적용해본것이 테이블에 적용되있기 때문이다. 

//주의
//dis[5][3] + dis[3][4]가 최솟값인지 볼 때, k가 1,2돌고 3을 적용해보는것이라고 해서 5 1 2 3 4 순서가 적용된게 아니다.
// dis[5][3]에는 앞서 k=2로적용된 값이 저장되어있고 (5-2-3이 최소비용인 상태가 d[5][3]에 남아있음), dis[3][4]에는 k=1로 적용된 값이 최소로 남아있어 314가 순서일 수 있다.
// 그렇다면 52314순서가 최소비용이 되는 것이다. 
// 또한, 이차원 배열에서 dis[5][3] 과 dis[3][4]은 앞서 3에대한 적용이 된 상태인데 [5][4]를 검사할 때 또 3을 적용하면 여러번 적용하는것이 아닌가?
// 5-3-3이지만 3-3은 처음부터 줄곧 0이기에 의미가 없다. 

#include <iostream>
#include <vector> 
#include <queue>
#include <algorithm>

using namespace std;

int main()
{
	ios_base::sync_with_stdio(false);
	int n, m, a, b, c;

	vector<vector<int>> dis(n + 1, vector<int>(n + 1, 5000)); // 2차원 배열 생성, 0은사용하지 않는다. max 5000

	for (int i = 1; i <= n; i++) {
		dis[i][i] = 0; // 자기자신에서 자기자신으로 오는것은 0으로 초기화
	}

	for (int i = 1; i <= m; i++) { //간선 갯수만큼 
		cin >> a >> b >> c;
		dis[a][b] = c; // 인접행렬값 초기화 a에서 b로가는데 c비용드는것을 적용. 
	}
	
	//플로이드 와샬. n개의 k에 대해서, i행, j열을 돌며 기존값과 비교, 갱신
	for (int k = 1; k <= n; k++) {
		for (int i = 1; i <= n; i++) {
			for (int j = 1; j <= n; j++) {
				if (dis[i][j] > dis[i][k] + dis[k][j])
					dis[i][j] = dis[i][k] + dis[k][j];
			}
		}
	}

	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= n; j++) {
			if (dis[i][j] == 5000) //갱신된 적 없이 max로 남아있다면.
				cout << "M ";
			else cout << dis[i][j] << " ";
		}
		cout << "\n";
	}
	return 0;
}
	

	
